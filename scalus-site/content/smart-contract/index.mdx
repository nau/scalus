---
#asIndexPage: true
#display: hidden
---
import { Steps, Tabs } from 'nextra/components'

# First Smart Contract

<Steps>
## Creating a new validator from the template
Let's seed a new Scalus validator:

```sh copy
sbt new scalus3/validator.g8
```
This ran the template scalus/validator.g8 using [Giter8](https://www.foundweekends.org/giter8/).
When prompted, name the application `htlc validator`. This command scaffolds a simple Scalus validator project.
```console
sbt new scalus3/validator.g8

name [MyValidator]: htlc validator

Template applied in ./htlc-validator
```
## Project structure
Let’s take a look at what just got generated:

```ansi
 htlc-validator/
    ├── HtlcValidator.scala        # Simple validator
    ├── HtlcValidator.test.scala   # Simple tests
    ├── project.scala              # Project configuration
    └── README.md
```

## HTLC Contract
Let's create a simple "Hello Cardano" validator script that verifies a specific message:

Create or open the file src/main/scala/com/example/contracts/HelloCardano.scala:
```scala copy
package scalus.examples

import scalus.*
import scalus.builtin.Data
import scalus.ledger.api.v3.{PubKeyHash, TxInfo, TxOutRef}
import scalus.prelude.*
import scalus.prelude.Prelude.*

/** A simple validator that checks if the redeemer is "Hello, World!" and if the transaction is
  * signed by the owner.
  */
@Compile
object HelloCardano extends Validator {
    inline override def spend(
        datum: Option[Data],
        redeemer: Data,
        tx: TxInfo,
        ownRef: TxOutRef
    ): Unit = {
        val owner = datum.getOrFail("Datum not found").to[PubKeyHash]
        val signed = tx.signatories.contains(owner)
        require(signed, "Must be signed")
        val saysHello = redeemer.to[String] == "Hello, World!"
        require(saysHello, "Invalid redeemer")
    }
}

```

This simple validator script demonstrates several key concepts:
- The @Compile annotation marks the object for on-chain compilation
- The `spend` method defines the spending validator logic
- Contract params, Datum, Redeemer are first-class Scala types
- The invariants are enforced using a `require` method

## Let's test our Smart Contract

todo: prettify hello-cardano test before finishing this section

## Debugging Smart Contract

Breakpoint

## Building Plutus script

```sh copy
sbt compile
```

Build?
Blueprint

## Evaluating Script
Now let's create a simple client to interact with our smart contract:

Create or open the file src/main/scala/com/example/offchain/Client.scala
```scala copy
...
```

</Steps>

Plutus contract blueprint
