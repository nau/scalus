import { Steps, Tabs } from 'nextra/components'

# First Decentralised Application

<Steps>
## Creating a new project
Let's seed a new Scalus project:

```sh copy
sbt new scalus/scalus-seed.g8
```
This ran the template scalus/scalus-seed.g8 using [Giter8](https://www.foundweekends.org/giter8/).
When prompted, name the application `hello-cardano`. This command scaffolds a Scalus project.
```console
sbt new scalus/contract-seed.g8
A minimal Scalus project.

name [Scalus Seed Project]: hello-cardano

Template applied in ./hello-cardano
```
## Project structure
Let’s take a look at what just got generated:

```ansi
hello-cardano/
├── build.sbt                 # Build configuration
├── project/
│   ├── build.properties      # SBT settings
│   └── plugins.sbt           # SBT plugins (including Scalus)
├── src/
│   ├── main/
│   │   ├── scala/            # Source code
│   │   │   └── hello
│   │   │       ├── Main.scala               # Main application
│   │   │       ├── contracts/                 # On-chain contracts
│   │   │       │   └── HelloCardano.scala     # Our validator
│   │   │       └── offchain/                # Off-chain code
│   │   │           └── TxBuilder.scala         # Transaction building logic
│   │   │           └── Server.scala            # Backend functionality
│   │   └── resources/        # Configuration files
│   │       └── application.conf
│   └── test/
│       └── scala/            # Test code
│           └── hello/
│               └── contracts/                   # Contracts tests
│                   └── HelloCardanoSpec.scala   # ...
└── README.md
```
## Hello Cardano Smart Contract
Let's create a simple "Hello Cardano" validator script that verifies a specific message:

Create or open the file src/main/scala/com/example/contracts/HelloCardano.scala:
```scala copy
...
```

This simple validator script demonstrates several key concepts:
- The @OnChain annotation marks the class for on-chain compilation
- The validate method defines the validation logic
- Contract params, Datum, Redeemer
- We're using the ScriptContext to access transaction information

## Let's test our Smart Contract

## Debugging Smart Contract

## Building Smart Contract

Build?
Blueprint

## Creating the Off-Chain Client
Now let's create a simple client to interact with our smart contract:

Create or open the file src/main/scala/com/example/offchain/Client.scala
```scala copy
...
```

</Steps>

Plutus contract blueprint