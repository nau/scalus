package scalus.uplc
import scalus.builtins.Builtins
import scalus.uplc.Data.FromData

import scala.quoted.*

/*
  WIP ToData derivation
 */
object TotoData {
  type ToData[A] = A => Data

  inline def deriveProduct[T](inline constrIdx: Int): ToData[T] = ${
    deriveProductMacro[T]('{ constrIdx })
  }

  def deriveProductMacro[T: Type](constrIdx: Expr[Int])(using Quotes): Expr[ToData[T]] =
    import quotes.reflect.*
    val classSym = TypeTree.of[T].symbol
    val companionModuleRef = classSym.companionModule
    val unapplyRef = companionModuleRef.memberMethod("unapply").head.termRef
    val constr = classSym.primaryConstructor
    val params = constr.paramSymss.flatten
    val sdf = params.map(p => p.name -> p.typeRef)
    /*
      TODO: generate a pattern match to introduce all the params,
      to avoid a.field1, a.field2, etc.
      That results in a lot of lambdas generated by Scalus.

      Something like:
        a match
          case A(field1, field2, ...) =>
            Builtins.mkConstr(
              BigInt($constrIdx),
              scalus.builtins.List(field1.toData, field2.toData, ...)
            )
     */
    def genMatch(prodTerm: Term, params: List[(String, TypeRepr)], rhs: Term)(using Quotes) = {
      val bindings = params.map { (name, tpe) =>
        Bind(Symbol.newBind(Symbol.noSymbol, name, Flags.EmptyFlags, tpe), Wildcard())
      }
      val m = Match(prodTerm, List(CaseDef(Unapply(Ident(unapplyRef), Nil, bindings), None, rhs)))
      m
    }

    def genArgs(prodTerm: Term)(using Quotes) =
      val args = params
        .map { param =>
          val tpe = param.termRef.widen.dealias
          tpe.asType match
            case '[t] =>
              Expr.summon[ToData[t]] match
                case None =>
                  report.errorAndAbort(s"Could not find implicit for FromData[${tpe.show}]")
                case Some(toData) =>
                  val arg = prodTerm.select(param).asExprOf[t]
                  '{ $toData($arg) }
              // '{ Builtins.mkI(12) }
        }
        .asInstanceOf[List[Expr[Data]]]
      args

    def genRhs(prodTerm: Term)(using Quotes) = '{
      Builtins.mkConstr(
        BigInt($constrIdx),
        ${
          /* val args = params
            .map { param =>
              val tpe = param.termRef.widen.dealias
              tpe.asType match
                case '[t] =>
                  Expr.summon[ToData[t]] match
                    case None =>
                      report.errorAndAbort(s"Could not find implicit for FromData[${tpe.show}]")
                    case Some(toData) =>
                      val arg = prodTerm.select(param).asExprOf[t]
                      '{ $toData($arg) }
            }
            .asInstanceOf[List[Expr[Data]]] */
          // val args = Nil
          genArgs(prodTerm).foldRight('{ scalus.builtins.Builtins.mkNilData() }) { (data, acc) =>
            '{ scalus.builtins.Builtins.mkCons($data, $acc) }
          }
        }
      )
    }

    val r = '{ (product: T) =>
      ${
        val prodTerm = '{ product }.asTerm
        // val rhs = '{ Builtins.mkI(12) }
        /* val rhs = '{
          Builtins.mkConstr(
            BigInt($constrIdx),
            scalus.builtins.Builtins.mkNilData()
          )
        } */
        val rhs = genRhs(prodTerm)
        genMatch(prodTerm, sdf, rhs.asTerm).asExprOf[Data]
      }
    }
    // println(r.asTerm.show)
    r

  extension [A: ToData](a: A) inline def toData: Data = summon[ToData[A]].apply(a)
}

/*
  WIP FromData derivation
 */
object FromData {

  inline def derived[T]: FromData[T] = ${ derivedMacro[T] }

  /** Derive FromData for an enum type
    *
    * @param conf
    *   a partial function mapping tag to constructor function, like
    * @return
    *   a FromData instance
    *
    * @example
    *   {{{
    *   enum Adt:
    *     case A
    *     case B(b: Boolean)
    *     case C(a: Adt, b: Adt)
    *
    *   given FromData[Adt] = FromData.deriveEnum[Adt] {
    *     case 0 => _ => Adt.A
    *     case 1 => FromData.deriveConstructor[Adt.B]
    *     case 2 => FromData.deriveConstructor[Adt.C]
    *     }
    *   }}}
    */
  inline def deriveEnum[T](
      inline conf: PartialFunction[Int, scalus.builtins.List[Data] => T]
  ): FromData[T] = ${ deriveEnumMacro[T]('{ conf }) }

  inline def deriveConstructor[T]: scalus.builtins.List[Data] => T = ${ deriveConstructorMacro[T] }

  def deriveConstructorMacro[T: Type](using Quotes): Expr[scalus.builtins.List[Data] => T] =
    import quotes.reflect.*
    val classSym = TypeTree.of[T].symbol
    val constr = classSym.primaryConstructor
    val params = constr.paramSymss.flatten
    val fromDataOfArgs = params.map { param =>
      val tpe = param.termRef.widen.dealias
      tpe.asType match
        case '[t] =>
          Expr.summon[FromData[t]] match
            case None => report.errorAndAbort(s"Could not find implicit for FromData[${tpe.show}]")
            case Some(value) => value
    }
    def genGetter(init: Expr[scalus.builtins.List[Data]], idx: Int)(using Quotes): Expr[Data] =
      var expr = init
      var i = 0
      while i < idx do
        val exp = expr // save the current expr, otherwise it will loop forever
        expr = '{ $exp.tail }
        i += 1
      '{ $expr.head }

    def genConstructorCall(
        a: Expr[scalus.builtins.List[scalus.uplc.Data]]
    )(using Quotes): Expr[T] = {
      val args = fromDataOfArgs.zipWithIndex.map { case (appl, idx) =>
        val arg = genGetter(a, idx)
        '{ $appl($arg) }.asTerm
      }
      // Couldn't find a way to do this using quotes, so just construct the tree manually
      New(TypeTree.of[T]).select(constr).appliedToArgs(args).asExprOf[T]
    }
    '{ (args: scalus.builtins.List[scalus.uplc.Data]) => ${ genConstructorCall('{ args }) } }

  def derivedMacro[T: Type](using Quotes): Expr[FromData[T]] =
    '{ (d: Data) =>
      val args = scalus.builtins.Builtins.unsafeDataAsConstr(d).snd

      // generate f = (args) => new Constructor(args.head, args.tail.head, ...)
      // then apply to args: f(args)
      // and finally beta reduce it in compile time
      ${ Expr.betaReduce('{ ${ deriveConstructorMacro[T] }(args) }) }
    }

  def deriveEnumMacro[T: Type](conf: Expr[PartialFunction[Int, scalus.builtins.List[Data] => T]])(
      using Quotes
  ): Expr[FromData[T]] =
    import quotes.reflect.*
    val mapping = conf.asTerm match
      case Inlined(_, _, Block(List(DefDef(_, _, _, Some(Match(_, cases)))), _)) =>
        cases.map { case CaseDef(Literal(IntConstant(tag)), _, code) =>
          (tag, code.asExprOf[scalus.builtins.List[Data] => T])
        }
    // stage programming is cool, but it's hard to comprehend what's going on
    '{ (d: Data) =>
      val pair = Builtins.unsafeDataAsConstr(d)
      val tag = pair.fst
      val args = pair.snd
      ${
        mapping.foldRight('{ throw new Exception("Invalid tag") }.asExprOf[T]) {
          case ((t, code), acc) =>
            '{ if Builtins.equalsInteger(tag, BigInt(${ Expr(t) })) then $code(args) else $acc }
        }
      }
    }
}
