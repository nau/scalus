"use strict";(self.webpackChunkscalus_website=self.webpackChunkscalus_website||[]).push([[423],{3348:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>l,toc:()=>c});var t=a(5893),i=a(1151);const s={sidebar_position:2},r="Tutorial",l={id:"Tutorial",title:"Tutorial",description:"Basic workflow",source:"@site/../scalus-docs/target/mdoc/Tutorial.md",sourceDirName:".",slug:"/Tutorial",permalink:"/docs/Tutorial",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Quick Start",permalink:"/docs/Installation"},next:{title:"Examples",permalink:"/docs/Examples"}},o={},c=[{value:"Basic workflow",id:"basic-workflow",level:2},{value:"Simple validator",id:"simple-validator",level:2},{value:"Constans and primitives",id:"constans-and-primitives",level:2},{value:"Builtin Functions",id:"builtin-functions",level:2},{value:"Data types",id:"data-types",level:2},{value:"Control flow",id:"control-flow",level:2},{value:"Functions",id:"functions",level:2},{value:"Modules and reusable code",id:"modules-and-reusable-code",level:2},{value:"FromData",id:"fromdata",level:2},{value:"Writing a validator",id:"writing-a-validator",level:2},{value:"Converting the Scalus code to Flat/CBOR encoded UPLC",id:"converting-the-scalus-code-to-flatcbor-encoded-uplc",level:2},{value:"Evaluating scripts",id:"evaluating-scripts",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"tutorial",children:"Tutorial"}),"\n",(0,t.jsx)(n.h2,{id:"basic-workflow",children:"Basic workflow"}),"\n",(0,t.jsx)(n.p,{children:"The basic workflow is to write a Scala program and then compile it to a Plutus script,\nsimilar to how PlutuxTx works."}),"\n",(0,t.jsxs)(n.p,{children:["You can store the Plutus script in a ",(0,t.jsx)(n.code,{children:"*.plutus"})," file and use it with the Cardano CLI.\nOr use one of the Java/JavaScript libraries to construct transactions with the script."]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/nau/scalus/blob/d42d24385666efdb2690321958aa4fb8108e2db5/examples/src/main/scala/scalus/SendTx.scala",children:"This example"})," shows how to use the ",(0,t.jsx)(n.a,{href:"https://github.com/bloxbean/cardano-client-lib",children:"cardano-client-lib"})," to send transactions."]}),"\n",(0,t.jsxs)(n.p,{children:["You write a script using a small subset of Scala,\nwhich is then compiled to a Scalus Intermediate Representation (SIR) with ",(0,t.jsx)(n.code,{children:"compile"})," function."]}),"\n",(0,t.jsx)(n.p,{children:"The SIR can be pretty-printed and reviewed."}),"\n",(0,t.jsx)(n.p,{children:"The SIR is then compiled to Untyped Plutus Core (UPLC) that can be executed on the Cardano blockchain."}),"\n",(0,t.jsx)(n.h2,{id:"simple-validator",children:"Simple validator"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.Compiler.compile\nimport scalus.*\nimport scalus.builtin.Data\n\n// Compile Scala code to Scalus Intermediate Representation (SIR)\nval validator = compile {\n    // A simple validator that always succeeds\n    (datum: Data, redeemer: Data, context: Data) => ()\n}\n// validator: SIR = LamAbs(\n//   name = "datum",\n//   term = LamAbs(\n//     name = "redeemer",\n//     term = LamAbs(name = "context", term = Const(const = Unit))\n//   )\n// )\nvalidator.pretty.render(80)\n// res0: String = "{\u03bb datum redeemer context -> () }"\nvalidator.toUplc().pretty.render(80)\n// res1: String = """(lam datum\n//   (lam redeemer\n//     (lam context\n//       (con unit ()))))"""\nvalidator.doubleCborHex(version = (1, 0, 0))\n// res2: String = "4746010000222499"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"constans-and-primitives",children:"Constans and primitives"}),"\n",(0,t.jsxs)(n.p,{children:["Plutus supports the following primitive types: ",(0,t.jsx)(n.code,{children:"unit"}),", ",(0,t.jsx)(n.code,{children:"bool"}),", ",(0,t.jsx)(n.code,{children:"integer"}),", ",(0,t.jsx)(n.code,{children:"bytestring"}),", ",(0,t.jsx)(n.code,{children:"string"}),", ",(0,t.jsx)(n.code,{children:"data"}),",  ",(0,t.jsx)(n.code,{children:"list"}),", ",(0,t.jsx)(n.code,{children:"pair"}),".\nThose types are represented in Scalus as ",(0,t.jsx)(n.code,{children:"Unit"}),", ",(0,t.jsx)(n.code,{children:"Boolean"}),", ",(0,t.jsx)(n.code,{children:"BigInt"}),", ",(0,t.jsx)(n.code,{children:"ByteString"}),", ",(0,t.jsx)(n.code,{children:"String"}),", ",(0,t.jsx)(n.code,{children:"Data"}),", ",(0,t.jsx)(n.code,{children:"List"}),", ",(0,t.jsx)(n.code,{children:"Pair"})," respectively."]}),"\n",(0,t.jsxs)(n.p,{children:["We use Scala native types to represent ",(0,t.jsx)(n.code,{children:"Unit"}),", ",(0,t.jsx)(n.code,{children:"Boolean"}),", ",(0,t.jsx)(n.code,{children:"BigInt"}),", and ",(0,t.jsx)(n.code,{children:"String"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Here is an example of how to define constants and use built-in types."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.Compiler.compile\nimport scalus.*\nimport scalus.builtin.*\nimport scalus.builtin.ByteString.given\n\nval constants = compile {\n    val unit = () // unit type\n    val bool = true || false // boolean type\n    val int = BigInt(123) // integer type\n    val bigint = BigInt("12345678901234567890") // large integer value\n    val implicitBigIng: BigInt = 123\n    val emptyByteString = ByteString.empty\n    val byteString = ByteString.fromHex("deadbeef")\n    val byteStringUtf8 = ByteString.fromString("hello") // from utf8 encoded string\n    val byteString2 = hex"deadbeef" // ByteString from hex string\n    val string = "Scalus Rocks!" // string type\n    val emptyList = List.empty[BigInt] // empty list\n    val list = List[BigInt](1, 2, 3) // list of integers\n    val pair = Pair(true, ()) // pair of boolean and unit\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"builtin-functions",children:"Builtin Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.builtin.*\nimport scalus.builtin.ByteString.given\nimport scalus.prelude.Prelude.{*, given}\ncompile {\n    // See scalus.builtin.Builtins for what is available\n    val data = Builtins.iData(123)\n    val eqData = data == Builtins.iData(123) || data != Builtins.iData(123)\n    val eq = Builtins.equalsByteString(hex"deadbeef", ByteString.empty)\n    val byteStringEq = hex"deadbeef" == ByteString.empty || hex"deadbeef" != ByteString.empty\n    val stringEq = "deadbeef" == "" || "deadbeef" != ""\n    val a = BigInt(1)\n    val sum = a + 1 - a * 3 / 4 // arithmetic operators\n    val intEquality = a == sum || a != sum\n    val bool = !true || (false == true) != false && true // boolean operators\n    val equals = a === sum // comparison operators\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"data-types",children:"Data types"}),"\n",(0,t.jsx)(n.p,{children:"You can define your own data types using Scala case classes and enums."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import scalus.builtin.ByteString\nimport scalus.prelude.Prelude.{*, given}\n\ncase class Account(hash: ByteString, balance: BigInt)\n\nenum State:\n    case Empty\n    case Active(account: Account)\n\nimport State.*\ncompile {\n    // Tuple2 literals are supported\n    val tuple = (true, BigInt(123))\n    val empty = State.Empty // simple constructor\n    // Use `new` to create an instance\n    val account = new Account(ByteString.empty, tuple._2) // access tuple fields\n    val active: State = new State.Active(account)\n    val hash = account.hash // access case class fields\n    // A simple pattern matching is supported\n    // no guards, no type ascriptions.\n    // Inner matches can be done only on single constructor case classes\n    // Wildcard patterns are supported\n    active match\n        case Empty                                 => true\n        case Active(account @ Account(_, balance)) => balance == BigInt(123)\n    // all cases must be covered or there must be a default case\n    val isEmpty = active match\n        case Empty => true\n        case _     => false\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"control-flow",children:"Control flow"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.prelude.Prelude.{*, given}\ncompile {\n    val a = BigInt(1)\n    // if-then-else\n    if a == BigInt(2) then ()\n    // throwing an exception compiles to Plutus ERROR,\n    // which aborts the evaluation of the script\n    // the exception message can be translated to a trace message\n    // using sir.toUplc(generateErrorTraces = true)\n    else throw new Exception("not 2")\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"compile {\n    val nonRecursiveLambda = (a: BigInt) => a + 1\n\n    def recursive(a: BigInt): BigInt =\n        if a == BigInt(0) then 0\n        else recursive(a - 1)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"modules-and-reusable-code",children:"Modules and reusable code"}),"\n",(0,t.jsxs)(n.p,{children:["You can define reusable code in a Scala object annotated with ",(0,t.jsx)(n.code,{children:"@Compile"}),".\nScalus will compile the code to *.sir files and include them in the jar file.\nThis way you can distribute your code as a library."]}),"\n",(0,t.jsxs)(n.p,{children:["Use ",(0,t.jsx)(n.code,{children:"@Ignore"})," to exclude a definition from the compilation."]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"compile"})," will link the modules together and compile them to a single script."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"\n@Compile\nobject ReusableCode {\n    val constant = BigInt(1)\n    def usefulFunction(a: BigInt): BigInt = a + 1\n    @Ignore // this function is not compiled to UPLC\n    def shouldNotBeInUplc() = ???\n}\n\nval modules = compile {\n    ReusableCode.usefulFunction(ReusableCode.constant)\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"fromdata",children:"FromData"}),"\n",(0,t.jsx)(n.p,{children:"FromData type class is used to convert a Data value to a Scalus value."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:"import scalus.builtin.*, Builtins.*, Data.*\nimport scalus.builtin.FromDataInstances.given\n\ncase class Account(hash: ByteString, balance: BigInt)\n\nenum State:\n    case Empty\n    case Active(account: Account)\n\n\nval fromDataExample = compile {\n    // The `fromData` function is used to convert a `Data` value to a Scalus value.\n    val data = iData(123)\n    // fromData is a summoner method for the `FromData` type class\n    // there are instances for all built-in types\n    val a = fromData[BigInt](data)\n\n    // you can define your own `FromData` instances\n    {\n        given FromData[Account] = (d: Data) => {\n            val args = unConstrData(d).snd\n            new Account(fromData[ByteString](args.head), fromData[BigInt](args.tail.head))\n        }\n        val account = fromData[Account](data)\n    }\n\n    // or your can you a macro to derive the FromData instance\n    {\n        given FromData[Account] = FromData.deriveCaseClass\n        given FromData[State] = FromData.deriveEnum[State] {\n            case 0 => d => State.Empty\n            case 1 => FromData.deriveConstructor[State.Active]\n        }\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"writing-a-validator",children:"Writing a validator"}),"\n",(0,t.jsx)(n.p,{children:"Here is a simple example of a PlutusV2 validator written in Scalus."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.ledger.api.v2.*\nimport scalus.ledger.api.v2.FromDataInstances.given\nimport scalus.builtin.ByteString.given\nimport scalus.builtin.Data.fromData\nimport scalus.prelude.List\n\n// Use Scala 3 indentation syntax. Look ma, no braces! Like Python!\nval pubKeyValidator = compile:\n    def validator(datum: Data, redeamder: Data, ctxData: Data) =\n        val ctx = fromData[ScriptContext](ctxData)\n        List.findOrFail[PubKeyHash](ctx.txInfo.signatories):\n            sig => sig.hash == hex"deadbeef"\n'})}),"\n",(0,t.jsx)(n.h2,{id:"converting-the-scalus-code-to-flatcbor-encoded-uplc",children:"Converting the Scalus code to Flat/CBOR encoded UPLC"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"compile"})," function converts the Scalus code to a ",(0,t.jsx)(n.code,{children:"SIR"})," value, Scalus Intermediate Representation.\nYou then need to convert the ",(0,t.jsx)(n.code,{children:"SIR"})," value to a UPLC value and encode it to Flat and then to CBOR."]}),"\n",(0,t.jsxs)(n.p,{children:["Many APIs require the HEX encoded string of double CBOR encoded Flat encoded UPLC program,\nlike ",(0,t.jsx)(n.code,{children:"Hex(CborEncode(CborEncode(FlatEncode(Program(version, uplc)))))"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.*\nimport scalus.builtin.ByteString.given\nimport scalus.builtin.Data.fromData\nimport scalus.ledger.api.PlutusLedgerLanguage\nimport scalus.ledger.api.v2.*\nimport scalus.ledger.api.v2.FromDataInstances.given\nimport scalus.prelude.List\nimport scalus.uplc.Program\n\nval serializeToDoubleCborHex = {\n    val pubKeyValidator = compile {\n        def validator(datum: Data, redeamder: Data, ctxData: Data) = {\n            val ctx = fromData[ScriptContext](ctxData)\n            List.findOrFail[PubKeyHash](ctx.txInfo.signatories)(sig => sig.hash == hex"deadbeef")\n        }\n    }\n    // convert to UPLC\n    // generateErrorTraces = true will add trace messages to the UPLC program\n    val uplc = pubKeyValidator.toUplc(generateErrorTraces = true)\n    val program = Program((1, 0, 0), uplc)\n    val flatEncoded = program.flatEncoded // if needed\n    val cbor = program.cborEncoded // if needed\n    val doubleEncoded = program.doubleCborEncoded // if needed\n    // in most cases you want to use the hex representation of the double CBOR encoded program\n    program.doubleCborHex\n    // also you can produce a pubKeyValidator.plutus file for use with cardano-cli\n    import scalus.utils.Utils\n    Utils.writePlutusFile("pubKeyValidator.plutus", program, PlutusLedgerLanguage.PlutusV2)\n    // or simply\n    program.writePlutusFile("pubKeyValidator.plutus", PlutusLedgerLanguage.PlutusV2)\n}\n'})}),"\n",(0,t.jsx)(n.h2,{id:"evaluating-scripts",children:"Evaluating scripts"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-scala",children:'import scalus.builtin.{*, given}\nimport scalus.ledger.api.*\nimport scalus.uplc.*, eval.*\n\ndef evaluation() = {\n    val sir = compile {\n        def usefulFunction(a: BigInt): BigInt = a + 1\n        usefulFunction(1)\n    }\n    val term = sir.toUplc()\n    // simply evaluate the term\n    VM.evaluateTerm(term).pretty.render(80) // (con integer 2)\n    // evaluate a flat encoded script and calculate the execution budget and logs\n    val result =\n        VM.evaluateScriptCounting(MachineParams.defaultParams, Program((1, 0, 0), term).flatEncoded)\n    println(s"Execution budget: ${result.budget}")\n    println(s"Evaluated term: ${result.term.pretty.render(80)}")\n    println(s"Logs: ${result.logs.mkString("\\n")}")\n\n    // you can get the actual execution costs from protocol parameters JSON from cardano-cli\n    lazy val machineParams = MachineParams.fromCardanoCliProtocolParamsJson(\n      "JSON with protocol parameters",\n      PlutusLedgerLanguage.PlutusV2\n    )\n    // or from blockfrost API\n    lazy val machineParams2 = MachineParams.fromBlockfrostProtocolParamsJson(\n      "JSON with protocol parameters",\n      PlutusLedgerLanguage.PlutusV2\n    )\n\n    // CountingBudgetSpender is a budget spender that counts the total cost of the evaluation\n    val countingBudgetSpender = CountingBudgetSpender()\n    // TallyingBudgetSpender is a budget spender that counts the costs of each operation\n    val tallyingBudgetSpender = TallyingBudgetSpender(countingBudgetSpender)\n    val logger = Log()\n    // use NoLogger to disable logging\n    val noopLogger = NoLogger\n    val cekMachine = CekMachine(\n      MachineParams.defaultParams, // or use default params\n      tallyingBudgetSpender,\n      logger,\n      JVMPlatformSpecific // platform specific functions. Use JSPlatformSpecific for Scala.js\n    )\n    val debruijnedTerm = DeBruijn.deBruijnTerm(term)\n    try {\n        cekMachine.evaluateTerm(debruijnedTerm)\n    } catch {\n        case e: StackTraceMachineError =>\n            println(s"Error: ${e.getMessage}")\n            println(s"Stacktrace: ${e.getCekStack}")\n            println(s"Env: ${e.env}")\n    }\n    println(s"Execution budget: ${tallyingBudgetSpender.budgetSpender.getSpentBudget}")\n    println(s"Logs: ${logger.getLogs.mkString("\\n")}")\n    println(\n      s"Execution stats:\\n${tallyingBudgetSpender.costs.toArray.sortBy(_._1.toString()).map {\n        case (k, v) => s"$k: $v"\n      }.mkString("\\n")}"\n    )\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,a)=>{a.d(n,{Z:()=>l,a:()=>r});var t=a(7294);const i={},s=t.createContext(i);function r(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);