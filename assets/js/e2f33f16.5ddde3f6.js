"use strict";(self.webpackChunkscalus_website=self.webpackChunkscalus_website||[]).push([[325],{365:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>i,contentTitle:()=>l,default:()=>B,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"internal/Typing","title":"Typing","description":"Supported scala types:","source":"@site/../scalus-docs/target/mdoc/internal/Typing.md","sourceDirName":"internal","slug":"/internal/Typing","permalink":"/docs/internal/Typing","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Examples","permalink":"/docs/Examples"}}');var a=n(4848),r=n(8453);const c={},l=void 0,i={},o=[];function d(e){const s={code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(s.p,{children:"Supported scala types:"}),"\n",(0,a.jsxs)(s.ul,{children:["\n",(0,a.jsx)(s.li,{children:"Scala Primitives types, mapped to appropriate SIR Primitive types."}),"\n",(0,a.jsx)(s.li,{children:"scalus.Builtin.Data, mapped to SIRType.Data"}),"\n",(0,a.jsx)(s.li,{children:"scala case classes"}),"\n"]}),"\n",(0,a.jsx)(s.p,{children:"Type:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"package x\ncase class A(x:BigInt, y:ByteString)\n"})}),"\n",(0,a.jsx)(s.p,{children:"should be translated to"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:' CaseClass(ConstrDecl("A",\n                      TypeBindings("x"-> TypeInteger, "y" -> TypeByteString), \n                      Nil),\n           Nil)\n'})}),"\n",(0,a.jsx)(s.p,{children:'Q:  A or x.A or PackagedName("x","A")'}),"\n",(0,a.jsx)(s.p,{children:"Type:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"sealed trait A\ncase class B(x:BigInt, y: BigInt) extends A\ncase class C(x:ByteString, b:B) extends A\ncase object D extends A\n"})}),"\n",(0,a.jsx)(s.p,{children:"should be"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:'A:  Type = SumCaseClass(dataDeclA)\n  dataDeclA = DataDecl("A",List(consrB,constrC,constrD), Nil, Nil)\nB:  Type = CaseClass(constrB)\n  constrB = ConstrDecl("B", st, List("x"->Integer,"y"->Integer), Nil)\nC:  Type = CaseClass(constrC)\n  constrC = ConstrDecl("C", st, List("x"->ByteString,"b"->B.Type), Nil)\nD:  Type = CaseClass(constrD)\n  constrD = ConstrDecl("D", st, List("x"->ByteString,"y"->ByteString), Nil)\n\n'})}),"\n",(0,a.jsx)(s.p,{children:"Hierarchy"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:" package x\n\n sealed trait BaseA\n sealed trait ChildA1BaseB extends Base\n case class B1(x: BigInt) extends ChildA1BaseB \n case class B2(y: BigInt) extends ChildA1BaseB \n case object C extends BaseA\n\n"})}),"\n",(0,a.jsx)(s.p,{children:"Now is officially not supported.\nTechnically can be translated to"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:'  BaseA: dataDeclA = DataDecl("BaseA",List(constrB1,constrB2,constrC),Nil)\n     Type: SumCaseClass(dataDeclA)\n\n  ChildA1BaseB: dataDeclA1B = DataDecl("ChildA1BaseB",List(constrB1,constrB2),Nil,Nil)\n     Type: SumCaseClass(dataDeclA1B)\n\n  B1: constrB1 = ConstrDecl("B1",List("x"-> TypeInteger), Nil, Nil)\n     Type = CaseClass(constrB1,Nil)\n  B2: constrB2 = ConstrDecl("B2",List("y"-> TypeInteger), Nil, Nil)\n     Type = CaseClass(constrB1,Nil)\n\n  C: constrC = ConstrDecl("C",Nil,Nil,Nil)\n\n'})}),"\n",(0,a.jsx)(s.p,{children:"But here we have a problem, which illustrated by example with type params (later)"}),"\n",(0,a.jsx)(s.p,{children:"In theory, can be translated to:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:'\n  BaseA: dataDeclA = DataDecl("BaseA",List(constrA1B,constrC),Nil)\n  ChildA1BaseB: \n       constrA1B: ConstrDecl("ChildA1BaseB_BaseA", List("_value" -> ChildA1BaseB)), flag="syntetic"\n       dataDeclA1B = DataDecl("ChildA1BaseB",List(constrB1,constrB2),Nil,Nil)\n       Type = SumCaseClass(dataDecl1A1B, .. parentConstr = constrA1B)\n  B1: constrB1 (same as prev)  \n  B2: constrB2 (same as prev)  \n\n'})}),"\n",(0,a.jsx)(s.p,{children:"With type parameters:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:"package x\n\nsealed trait BaseA[X]\nsealed trait BaseB[X] extends BaseA[Option[X]]\ncase class B1(x: BigInt) extends BaseB[BigInt]\ncase class B2(y: BigInt) extends BaseB[BigInt]\ncase object C extends BaseA[Nothing]\n"})}),"\n",(0,a.jsx)(s.p,{children:"Now if we have class B1, then type-parameter that this is BaseB[BigInt] is lost.\n(and we can put same constr in two places)"}),"\n",(0,a.jsx)(s.p,{children:"Now:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:'  BaseA: dataDeclBaseA = DataDecl("BaseA",List(constrB1,constrB2,constrC),List(TypeVar("X")))\n    Type = TypeLambda:X =>> SumCaseClass(dataDeclBaseA,X)\n'})}),"\n",(0,a.jsx)(s.p,{children:"Should be:"}),"\n",(0,a.jsx)(s.pre,{children:(0,a.jsx)(s.code,{children:'  BaseA: \n    dataDeclBaseA = DataDecl("BaseA",List(constrBaseB,constrC),List(TypeVar("X",1)))\n    Type = TypeLambda:X =>> SumCaseClass(dataDeclBaseA,X)\n\n  BaseB: \n    dataDeclBaseB = DataDecl("BaseB",List(constrB1, constrB2), List(TypeVar("X",2)))\n    constrB = ConstrDecl("BaseB_BaseA", List("_value" -> ChildA1BaseB), List(TypeVar("X",3), List(`Option[X]`)), flag="syntetic"\n \n  B1: constrB1 = ConstrDecl("B1",List("x"-> TypeInteger), Nil, List(TypeInteger))\n    Type = CaseClass(constrB1)\n  B2: constrB2 = ConstrDecl("B2",List("y"-> TypeInteger), Nil, List(TypeInteger))\n    Type = CaseClass(constrB2)\n  C: constrC = ConstrDecl("C",List("y"-> TypeInteger), Nil, List(TypeInteger))\n'})}),"\n",(0,a.jsx)(s.p,{children:"TODO:"}),"\n",(0,a.jsx)(s.p,{children:"enums"}),"\n",(0,a.jsx)(s.p,{children:"Type Parameter"})]})}function B(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,a.jsx)(s,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>l});var t=n(6540);const a={},r=t.createContext(a);function c(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function l(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);