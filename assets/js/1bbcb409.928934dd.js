"use strict";(self.webpackChunkscalus_website=self.webpackChunkscalus_website||[]).push([[803],{2978:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=t(5893),i=t(1151);const r={sidebar_position:3},o="Examples",s={id:"Examples",title:"Examples",description:"AdaStream",source:"@site/../scalus-docs/target/mdoc/Examples.md",sourceDirName:".",slug:"/Examples",permalink:"/docs/Examples",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Tutorial",permalink:"/docs/Tutorial"}},l={},c=[{value:"AdaStream",id:"adastream",level:2},{value:"AdaStream Example",id:"adastream-example",level:2},{value:"TL;DR",id:"tldr",level:3},{value:"PreImage Validator",id:"preimage-validator",level:2},{value:"Minting Policy",id:"minting-policy",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.h2,{id:"adastream",children:"AdaStream"}),"\n",(0,a.jsx)(n.h2,{id:"adastream-example",children:"AdaStream Example"}),"\n",(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.a,{href:"https://github.com/nau/adastream",children:"AdaStream"})," - Decentralized File Hosting Incentivised via Cardano Ada Payments"]}),"\n",(0,a.jsxs)(n.p,{children:["This project is a Cardano implementation of the ",(0,a.jsx)(n.a,{href:"https://github.com/RobinLinus/BitStream",children:"BitStream"})," protocol by Robin\nLinus."]}),"\n",(0,a.jsxs)(n.p,{children:["Original paper: ",(0,a.jsx)(n.a,{href:"https://robinlinus.com/bitstream.pdf",children:"BitStream: Decentralized File Hosting Incentivised via Bitcoin Payments\n"})]}),"\n",(0,a.jsx)(n.h3,{id:"tldr",children:"TL;DR"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Alice wants to buy a file from Bob."}),"\n",(0,a.jsx)(n.li,{children:"Bob encrypts the file with a random key and sends it to Alice."}),"\n",(0,a.jsx)(n.li,{children:"Bob creates a bond contract on Cardano with a collateral and a commitment to the key and the file."}),"\n",(0,a.jsx)(n.li,{children:"Alice pays Bob for the file via a HTLC (Hash Time Lock Contract), using Cardano or Bitcoin Lightning Network."}),"\n",(0,a.jsx)(n.li,{children:"Alice decrypts the file with the key from the HTLC or takes the money back after the timeout."}),"\n",(0,a.jsx)(n.li,{children:"If Bob cheats, Alice can prove it and get the collateral from the bond contract."}),"\n",(0,a.jsx)(n.li,{children:"Bob can withdraw the collateral by revealing the key."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"The project includes a bond contract and a HTLC contract for a fair exchange of files for ADA."}),"\n",(0,a.jsx)(n.p,{children:"It's a CLI tool and a REST API server that allows you to create a bond contract, pay for a file, and decrypt it."}),"\n",(0,a.jsx)(n.p,{children:"It has a set of tests that check the contract logic and its execution costs."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-scala",metastring:"3 mdoc:compile-only",children:'package adastream\n\nimport scalus.*\nimport scalus.Compiler.fieldAsData\nimport scalus.builtin.Builtins.*\nimport scalus.builtin.Data.{FromData, ToData, fromData, toData}\nimport scalus.builtin.ToDataInstances.given\nimport scalus.builtin.{ByteString, Data, FromData, List, ToData, given}\nimport scalus.ledger.api.v1.Extended\nimport scalus.ledger.api.v1.FromDataInstances.given\nimport scalus.ledger.api.v2.*\nimport scalus.utils.Utils\n\nextension (a: Array[Byte]) def toHex: String = Utils.bytesToHex(a)\n\n@Compile\nobject BondContract {\n    case class BondConfig(\n        preimageHash: ByteString,\n        encId: ByteString,\n        serverPubKey: ByteString,\n        serverPkh: ByteString\n    )\n\n    enum BondAction:\n        case Withdraw(preimage: ByteString)\n        case FraudProof(\n            signature: ByteString,\n            preimage: ByteString,\n            encryptedChunk: ByteString,\n            chunkHash: ByteString,\n            chunkIndex: BigInt,\n            merkleProof: Data // List of ByteString\n        )\n\n    import scalus.builtin.FromDataInstances.given\n    given FromData[BondConfig] = FromData.deriveCaseClass\n    given ToData[BondConfig] = ToData.deriveCaseClass[BondConfig](0)\n\n    given FromData[BondAction] = FromData.deriveEnum {\n        case 0 => FromData.deriveConstructor[BondAction.Withdraw]\n        case 1 => FromData.deriveConstructor[BondAction.FraudProof]\n    }\n    given ToData[BondAction] = (a: BondAction) =>\n        a match\n            case BondAction.Withdraw(preimage) =>\n                constrData(0, preimage.toData :: mkNilData())\n            case BondAction.FraudProof(\n                  signature,\n                  preimage,\n                  encryptedChunk,\n                  chunkHash,\n                  chunkIndex,\n                  merkleProof\n                ) =>\n                constrData(\n                  1,\n                  signature.toData\n                      :: preimage.toData\n                      :: encryptedChunk.toData\n                      :: chunkHash.toData\n                      :: chunkIndex.toData\n                      :: merkleProof\n                      :: mkNilData()\n                )\n\n    def integerToByteString(num: BigInt): ByteString =\n        def loop(div: BigInt, result: ByteString): ByteString = {\n            val shifted = num / div\n            val newResult = consByteString(shifted % 256, result)\n            if shifted == BigInt(0) then newResult\n            else loop(div * 256, newResult)\n        }\n        loop(1, ByteString.empty)\n\n    def xorBytes(a: BigInt, b: BigInt): BigInt = {\n        def xorHelper(a: BigInt, b: BigInt, pow: BigInt, result: BigInt): BigInt = {\n            if pow == BigInt(256) then result\n            else xorHelper(a / 2, b / 2, pow * 2, result + ((a + b) % 2) * pow)\n        }\n        xorHelper(a, b, 1, 0)\n    }\n\n    // a and b are of the same length\n    def xor(a: ByteString, b: ByteString): ByteString = {\n        val l1 = lengthOfByteString(a)\n        val l2 = lengthOfByteString(b)\n        def xorHelper(a: ByteString, b: ByteString, i: BigInt, result: ByteString): ByteString = {\n            if i < 0 then result\n            else {\n                val byteA = indexByteString(a, i)\n                val byteB = indexByteString(b, i)\n                val xorByte = xorBytes(byteA, byteB)\n                xorHelper(a, b, i - 1, consByteString(xorByte, result))\n            }\n        }\n        if l1 == l2 then xorHelper(a, b, l1 - 1, ByteString.empty)\n        else throw new Exception("X")\n    }\n\n    inline def verifyMerkleInclusionProof(\n        merkleProof: Data,\n        encryptedChunk: ByteString,\n        chunkHash: ByteString,\n        chunkIndex: BigInt,\n        encId: ByteString\n    ): Boolean =\n        val encryptedChunkAndChunkHashHash = sha2_256(\n          appendByteString(encryptedChunk, chunkHash)\n        )\n        def loop(index: BigInt, curHash: ByteString, siblings: List[Data]): ByteString =\n            if siblings.isEmpty then curHash\n            else\n                val sibling = unBData(siblings.head)\n                val nextHash =\n                    if index % 2 == BigInt(0)\n                    then sha2_256(appendByteString(curHash, sibling))\n                    else sha2_256(appendByteString(sibling, curHash))\n                loop(index / 2, nextHash, siblings.tail)\n\n        val merkleRoot = loop(chunkIndex, encryptedChunkAndChunkHashHash, unListData(merkleProof))\n        merkleRoot == encId\n\n    def verifyPreimage(preimage: ByteString, preimageHash: ByteString): Boolean =\n        preimageHash == sha2_256(preimage)\n\n    inline def verifyFraudProof(\n        chunkHash: ByteString,\n        chunkIndex: BigInt,\n        encId: ByteString,\n        encryptedChunk: ByteString,\n        merkleProof: Data,\n        preimage: ByteString,\n        preimageHash: ByteString,\n        serverPubKey: ByteString,\n        signature: ByteString\n    ): Boolean =\n        val verifyWrongChunkHash =\n            // hash( Ei \u2295 hash( preimage || i) ) \u2260 Hi\n            val expectedChunkHash = sha2_256(\n              trace("xor")(\n                xor(\n                  encryptedChunk,\n                  trace("sha2_256")(\n                    sha2_256(\n                      appendByteString(\n                        preimage,\n                        trace("integerToByteString")(integerToByteString(chunkIndex))\n                      )\n                    )\n                  )\n                )\n              )\n            )\n            expectedChunkHash != chunkHash\n        trace("verifyWrongChunkHash")(true)\n        val verifyValidClaimSignature = {\n            val claim = appendByteString(encId, preimageHash)\n            verifyEd25519Signature(\n              serverPubKey,\n              claim,\n              signature\n            )\n        }\n        trace("verifyValidClaimSignature")(true)\n\n        val verifyValidPreimage = verifyPreimage(preimage, preimageHash)\n        trace("verifyValidPreimage")(true)\n\n        val merkleInclusionProofValid = verifyMerkleInclusionProof(\n          merkleProof,\n          encryptedChunk,\n          chunkHash,\n          chunkIndex,\n          encId\n        )\n        (verifyWrongChunkHash || (throw new Exception("W")))\n        && (verifyValidClaimSignature || (throw new Exception("S")))\n        && (verifyValidPreimage || (throw new Exception("P")))\n        && (merkleInclusionProofValid || (throw new Exception("M")))\n\n    def bondContractValidator(datum: Data, redeemer: Data, ctxData: Data): Boolean = {\n        fromData[BondConfig](datum) match\n            case BondConfig(preimageHash, encId, serverPubKey, serverPkh) =>\n                val a = trace("fromData[BondConfig]")(true)\n                fromData[BondAction](redeemer) match\n                    case BondAction.Withdraw(preimage) =>\n                        val a = trace("BondAction.Withdraw(preimage)")(true)\n                        val signatories = fieldAsData[ScriptContext](_.txInfo.signatories)(ctxData)\n                        val pkh =\n                            unBData(unListData(signatories).head)\n                        val verifySignature = pkh == serverPkh\n                        val verifyValidPreimage = verifyPreimage(preimage, preimageHash)\n                        (verifySignature || (throw new Exception("S")))\n                        && (verifyValidPreimage || (throw new Exception("P")))\n                    case BondAction.FraudProof(\n                          signature,\n                          preimage,\n                          encryptedChunk,\n                          chunkHash,\n                          chunkIndex,\n                          merkleProof\n                        ) =>\n                        val a = trace("BondAction.FraudProof")(true)\n                        verifyFraudProof(\n                          chunkHash,\n                          chunkIndex,\n                          encId,\n                          encryptedChunk,\n                          merkleProof,\n                          preimage,\n                          preimageHash,\n                          serverPubKey,\n                          signature\n                        )\n    }\n\n    /*\n     * HTLC contract validator\n     */\n    def makeHtlcContractValidator(\n        clientPubKeyHash: Data,\n        expiration: POSIXTime,\n        hash: ByteString\n    )(datum: Data, redeemer: Data, ctxData: Data): Unit = {\n        val validPreimage = hash == sha2_256(unBData(redeemer))\n        val expired = {\n            val txInfoData = fieldAsData[ScriptContext](_.txInfo)(ctxData)\n            val signatoriesData = fieldAsData[TxInfo](_.signatories)(txInfoData)\n            val txtime = fromData[POSIXTimeRange](\n              fieldAsData[TxInfo](_.validRange)(txInfoData)\n            )\n            txtime.from.extended match\n                case Extended.Finite(txtime) =>\n                    val expired = expiration < txtime\n                    val signedByClient = {\n                        val signaturePubKeyHashData = unListData(signatoriesData).head\n                        signaturePubKeyHashData == clientPubKeyHash\n                    }\n                    expired && signedByClient\n                case _ => false\n        }\n        if validPreimage || expired then () else throw new Exception()\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"preimage-validator",children:"PreImage Validator"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/nau/scalus/blob/ce7a37edb06ef2e39794825ee4f81ff061198666/jvm/src/test/scala/scalus/PreImageExampleSpec.scala",children:"PreImage Validator"})}),"\n",(0,a.jsx)(n.h2,{id:"minting-policy",children:"Minting Policy"}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsx)(n.a,{href:"https://github.com/nau/scalus/blob/612b4bd581c55cb6c68339247cfecfbe22e4e61d/shared/src/main/scala/scalus/examples/MintingPolicy.scala",children:"MintingPolicy"})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>o});var a=t(7294);const i={},r=a.createContext(i);function o(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);